// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chat.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addParticipant = `-- name: AddParticipant :exec
INSERT INTO participants (
    conversation_id, 
    user_id, 
    role
) VALUES (
    $1, $2, $3
)
`

type AddParticipantParams struct {
	ConversationID int64       `json:"conversation_id"`
	UserID         string      `json:"user_id"`
	Role           pgtype.Text `json:"role"`
}

func (q *Queries) AddParticipant(ctx context.Context, arg AddParticipantParams) error {
	_, err := q.db.Exec(ctx, addParticipant, arg.ConversationID, arg.UserID, arg.Role)
	return err
}

const createConversation = `-- name: CreateConversation :one
INSERT INTO conversations (
    name, 
    avatar,
    is_group
) VALUES (
    $1, $2, $3
) RETURNING id, name, avatar, is_group, last_message_id, last_message_at, created_at, updated_at
`

type CreateConversationParams struct {
	Name    pgtype.Text `json:"name"`
	Avatar  pgtype.Text `json:"avatar"`
	IsGroup pgtype.Bool `json:"is_group"`
}

func (q *Queries) CreateConversation(ctx context.Context, arg CreateConversationParams) (Conversation, error) {
	row := q.db.QueryRow(ctx, createConversation, arg.Name, arg.Avatar, arg.IsGroup)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Avatar,
		&i.IsGroup,
		&i.LastMessageID,
		&i.LastMessageAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (
    conversation_id, 
    sender_id, 
    content, 
    type, 
    file_name, 
    file_path, 
    file_type, 
    file_size,
    reply_to_id,
    client_msg_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, conversation_id, sender_id, content, type, reply_to_id, is_deleted, created_at, file_name, file_id, file_path, file_type, file_size, client_msg_id
`

type CreateMessageParams struct {
	ConversationID int64       `json:"conversation_id"`
	SenderID       string      `json:"sender_id"`
	Content        pgtype.Text `json:"content"`
	Type           pgtype.Text `json:"type"`
	FileName       pgtype.Text `json:"file_name"`
	FilePath       pgtype.Text `json:"file_path"`
	FileType       pgtype.Text `json:"file_type"`
	FileSize       pgtype.Int8 `json:"file_size"`
	ReplyToID      pgtype.Int8 `json:"reply_to_id"`
	ClientMsgID    pgtype.Text `json:"client_msg_id"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ConversationID,
		arg.SenderID,
		arg.Content,
		arg.Type,
		arg.FileName,
		arg.FilePath,
		arg.FileType,
		arg.FileSize,
		arg.ReplyToID,
		arg.ClientMsgID,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Content,
		&i.Type,
		&i.ReplyToID,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.FileName,
		&i.FileID,
		&i.FilePath,
		&i.FileType,
		&i.FileSize,
		&i.ClientMsgID,
	)
	return i, err
}

const getConversationByID = `-- name: GetConversationByID :one
SELECT 
    c.id, c.name, c.avatar, c.is_group, c.last_message_id, c.last_message_at, c.created_at, c.updated_at, 
    m.content as last_message_content,
    m.sender_id as last_message_sender_id,
    m.type as last_message_type,
    m.file_name as last_message_file_name
FROM conversations c
LEFT JOIN messages m ON c.last_message_id = m.id
WHERE c.id = $1 LIMIT 1
`

type GetConversationByIDRow struct {
	ID                  int64            `json:"id"`
	Name                pgtype.Text      `json:"name"`
	Avatar              pgtype.Text      `json:"avatar"`
	IsGroup             pgtype.Bool      `json:"is_group"`
	LastMessageID       pgtype.Int8      `json:"last_message_id"`
	LastMessageAt       pgtype.Timestamp `json:"last_message_at"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
	LastMessageContent  pgtype.Text      `json:"last_message_content"`
	LastMessageSenderID pgtype.Text      `json:"last_message_sender_id"`
	LastMessageType     pgtype.Text      `json:"last_message_type"`
	LastMessageFileName pgtype.Text      `json:"last_message_file_name"`
}

func (q *Queries) GetConversationByID(ctx context.Context, id int64) (GetConversationByIDRow, error) {
	row := q.db.QueryRow(ctx, getConversationByID, id)
	var i GetConversationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Avatar,
		&i.IsGroup,
		&i.LastMessageID,
		&i.LastMessageAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastMessageContent,
		&i.LastMessageSenderID,
		&i.LastMessageType,
		&i.LastMessageFileName,
	)
	return i, err
}

const getMessagesByConversation = `-- name: GetMessagesByConversation :many
SELECT id, conversation_id, sender_id, content, type, reply_to_id, is_deleted, created_at, file_name, file_id, file_path, file_type, file_size, client_msg_id FROM messages
WHERE conversation_id = $1
AND ($2::bigint = 0 OR id < $2)
ORDER BY id DESC
LIMIT $3
`

type GetMessagesByConversationParams struct {
	ConversationID int64 `json:"conversation_id"`
	BeforeID       int64 `json:"before_id"`
	LimitCount     int32 `json:"limit_count"`
}

func (q *Queries) GetMessagesByConversation(ctx context.Context, arg GetMessagesByConversationParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, getMessagesByConversation, arg.ConversationID, arg.BeforeID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.Type,
			&i.ReplyToID,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.FileName,
			&i.FileID,
			&i.FilePath,
			&i.FileType,
			&i.FileSize,
			&i.ClientMsgID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrivateConversation = `-- name: GetPrivateConversation :one
SELECT p1.conversation_id
FROM participants p1
JOIN participants p2 ON p1.conversation_id = p2.conversation_id
JOIN conversations c ON p1.conversation_id = c.id
WHERE c.is_group = FALSE
  AND p1.user_id = $1 
  AND p2.user_id = $2
LIMIT 1
`

type GetPrivateConversationParams struct {
	UserID   string `json:"user_id"`
	UserID_2 string `json:"user_id_2"`
}

func (q *Queries) GetPrivateConversation(ctx context.Context, arg GetPrivateConversationParams) (int64, error) {
	row := q.db.QueryRow(ctx, getPrivateConversation, arg.UserID, arg.UserID_2)
	var conversation_id int64
	err := row.Scan(&conversation_id)
	return conversation_id, err
}

const listConversationsByUser = `-- name: ListConversationsByUser :many
SELECT 
    c.id, 
    c.name, 
    c.avatar,
    c.is_group,
    c.last_message_id,
    c.last_message_at,
    m.content as last_message_content,
    m.sender_id as last_message_sender_id,
    m.type as last_message_type,
    m.file_name as last_message_file_name,
    p.last_read_message_id,
    (
        SELECT COUNT(m2.id) 
        FROM messages m2 
        WHERE m2.conversation_id = c.id 
          AND m2.id > COALESCE(p.last_read_message_id, 0)
          AND m2.sender_id != $1
    ) as unread_count,
    (
        SELECT ARRAY_AGG(user_id)::TEXT[] 
        FROM participants 
        WHERE conversation_id = c.id
    ) as participant_ids
FROM conversations c
JOIN participants p ON c.id = p.conversation_id
LEFT JOIN messages m ON c.last_message_id = m.id
WHERE p.user_id = $1
ORDER BY c.last_message_at DESC
LIMIT $2 OFFSET $3
`

type ListConversationsByUserParams struct {
	SenderID string `json:"sender_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

type ListConversationsByUserRow struct {
	ID                  int64            `json:"id"`
	Name                pgtype.Text      `json:"name"`
	Avatar              pgtype.Text      `json:"avatar"`
	IsGroup             pgtype.Bool      `json:"is_group"`
	LastMessageID       pgtype.Int8      `json:"last_message_id"`
	LastMessageAt       pgtype.Timestamp `json:"last_message_at"`
	LastMessageContent  pgtype.Text      `json:"last_message_content"`
	LastMessageSenderID pgtype.Text      `json:"last_message_sender_id"`
	LastMessageType     pgtype.Text      `json:"last_message_type"`
	LastMessageFileName pgtype.Text      `json:"last_message_file_name"`
	LastReadMessageID   pgtype.Int8      `json:"last_read_message_id"`
	UnreadCount         int64            `json:"unread_count"`
	ParticipantIds      []string         `json:"participant_ids"`
}

func (q *Queries) ListConversationsByUser(ctx context.Context, arg ListConversationsByUserParams) ([]ListConversationsByUserRow, error) {
	rows, err := q.db.Query(ctx, listConversationsByUser, arg.SenderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListConversationsByUserRow
	for rows.Next() {
		var i ListConversationsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Avatar,
			&i.IsGroup,
			&i.LastMessageID,
			&i.LastMessageAt,
			&i.LastMessageContent,
			&i.LastMessageSenderID,
			&i.LastMessageType,
			&i.LastMessageFileName,
			&i.LastReadMessageID,
			&i.UnreadCount,
			&i.ParticipantIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listParticipantsByConversation = `-- name: ListParticipantsByConversation :many
SELECT user_id, role, joined_at, last_read_message_id
FROM participants 
WHERE conversation_id = $1
`

type ListParticipantsByConversationRow struct {
	UserID            string           `json:"user_id"`
	Role              pgtype.Text      `json:"role"`
	JoinedAt          pgtype.Timestamp `json:"joined_at"`
	LastReadMessageID pgtype.Int8      `json:"last_read_message_id"`
}

func (q *Queries) ListParticipantsByConversation(ctx context.Context, conversationID int64) ([]ListParticipantsByConversationRow, error) {
	rows, err := q.db.Query(ctx, listParticipantsByConversation, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListParticipantsByConversationRow
	for rows.Next() {
		var i ListParticipantsByConversationRow
		if err := rows.Scan(
			&i.UserID,
			&i.Role,
			&i.JoinedAt,
			&i.LastReadMessageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMessageAsRead = `-- name: MarkMessageAsRead :exec
UPDATE participants
SET last_read_message_id = $3
WHERE conversation_id = $1 AND user_id = $2
`

type MarkMessageAsReadParams struct {
	ConversationID    int64       `json:"conversation_id"`
	UserID            string      `json:"user_id"`
	LastReadMessageID pgtype.Int8 `json:"last_read_message_id"`
}

func (q *Queries) MarkMessageAsRead(ctx context.Context, arg MarkMessageAsReadParams) error {
	_, err := q.db.Exec(ctx, markMessageAsRead, arg.ConversationID, arg.UserID, arg.LastReadMessageID)
	return err
}

const removeParticipant = `-- name: RemoveParticipant :exec
DELETE FROM participants 
WHERE conversation_id = $1 AND user_id = $2
`

type RemoveParticipantParams struct {
	ConversationID int64  `json:"conversation_id"`
	UserID         string `json:"user_id"`
}

func (q *Queries) RemoveParticipant(ctx context.Context, arg RemoveParticipantParams) error {
	_, err := q.db.Exec(ctx, removeParticipant, arg.ConversationID, arg.UserID)
	return err
}

const updateConversationInfo = `-- name: UpdateConversationInfo :exec
UPDATE conversations
SET 
    name = $2, 
    avatar = $3,
    updated_at = now()
WHERE id = $1
`

type UpdateConversationInfoParams struct {
	ID     int64       `json:"id"`
	Name   pgtype.Text `json:"name"`
	Avatar pgtype.Text `json:"avatar"`
}

func (q *Queries) UpdateConversationInfo(ctx context.Context, arg UpdateConversationInfoParams) error {
	_, err := q.db.Exec(ctx, updateConversationInfo, arg.ID, arg.Name, arg.Avatar)
	return err
}

const updateConversationLastMessage = `-- name: UpdateConversationLastMessage :exec
UPDATE conversations
SET 
    last_message_id = $2, 
    last_message_at = $3,
    updated_at = now()
WHERE id = $1
`

type UpdateConversationLastMessageParams struct {
	ID            int64            `json:"id"`
	LastMessageID pgtype.Int8      `json:"last_message_id"`
	LastMessageAt pgtype.Timestamp `json:"last_message_at"`
}

func (q *Queries) UpdateConversationLastMessage(ctx context.Context, arg UpdateConversationLastMessageParams) error {
	_, err := q.db.Exec(ctx, updateConversationLastMessage, arg.ID, arg.LastMessageID, arg.LastMessageAt)
	return err
}

const updateLastReadMessage = `-- name: UpdateLastReadMessage :exec
UPDATE participants
SET last_read_message_id = $3
WHERE conversation_id = $1 AND user_id = $2
`

type UpdateLastReadMessageParams struct {
	ConversationID    int64       `json:"conversation_id"`
	UserID            string      `json:"user_id"`
	LastReadMessageID pgtype.Int8 `json:"last_read_message_id"`
}

func (q *Queries) UpdateLastReadMessage(ctx context.Context, arg UpdateLastReadMessageParams) error {
	_, err := q.db.Exec(ctx, updateLastReadMessage, arg.ConversationID, arg.UserID, arg.LastReadMessageID)
	return err
}
