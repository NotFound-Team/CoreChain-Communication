// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: meeting.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addMeetingInvite = `-- name: AddMeetingInvite :exec
INSERT INTO meeting_invites (meeting_id, user_id)
VALUES ($1, $2)
`

type AddMeetingInviteParams struct {
	MeetingID pgtype.UUID `json:"meeting_id"`
	UserID    string      `json:"user_id"`
}

func (q *Queries) AddMeetingInvite(ctx context.Context, arg AddMeetingInviteParams) error {
	_, err := q.db.Exec(ctx, addMeetingInvite, arg.MeetingID, arg.UserID)
	return err
}

const checkJoinPermission = `-- name: CheckJoinPermission :one
SELECT EXISTS (
    SELECT 1 FROM meetings m
    WHERE m.room_name = $1
    AND (
        m.host_id = $2
        OR EXISTS (
            SELECT 1 FROM meeting_invites mi 
            WHERE mi.meeting_id = m.id 
            AND mi.user_id = $2
        )
    )
    AND m.end_time IS NULL
) AS has_permission
`

type CheckJoinPermissionParams struct {
	RoomName string `json:"room_name"`
	UserID   string `json:"user_id"`
}

func (q *Queries) CheckJoinPermission(ctx context.Context, arg CheckJoinPermissionParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkJoinPermission, arg.RoomName, arg.UserID)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}

const createMeeting = `-- name: CreateMeeting :one
INSERT INTO meetings (
    title, description, host_id, room_name, meeting_key, start_time
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, title, description, host_id, room_name, meeting_key, start_time, end_time, is_active, created_at
`

type CreateMeetingParams struct {
	Title       string             `json:"title"`
	Description pgtype.Text        `json:"description"`
	HostID      string             `json:"host_id"`
	RoomName    string             `json:"room_name"`
	MeetingKey  string             `json:"meeting_key"`
	StartTime   pgtype.Timestamptz `json:"start_time"`
}

func (q *Queries) CreateMeeting(ctx context.Context, arg CreateMeetingParams) (Meeting, error) {
	row := q.db.QueryRow(ctx, createMeeting,
		arg.Title,
		arg.Description,
		arg.HostID,
		arg.RoomName,
		arg.MeetingKey,
		arg.StartTime,
	)
	var i Meeting
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.HostID,
		&i.RoomName,
		&i.MeetingKey,
		&i.StartTime,
		&i.EndTime,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const endMeeting = `-- name: EndMeeting :one
UPDATE meetings 
SET is_active = false, end_time = NOW() 
WHERE room_name = $1 AND host_id = $2 AND end_time IS NULL
RETURNING id, title, description, host_id, room_name, meeting_key, start_time, end_time, is_active, created_at
`

type EndMeetingParams struct {
	RoomName string `json:"room_name"`
	HostID   string `json:"host_id"`
}

func (q *Queries) EndMeeting(ctx context.Context, arg EndMeetingParams) (Meeting, error) {
	row := q.db.QueryRow(ctx, endMeeting, arg.RoomName, arg.HostID)
	var i Meeting
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.HostID,
		&i.RoomName,
		&i.MeetingKey,
		&i.StartTime,
		&i.EndTime,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getActiveMeetingByKey = `-- name: GetActiveMeetingByKey :one
SELECT id, title, description, host_id, room_name, meeting_key, start_time, end_time, is_active, created_at FROM meetings
WHERE meeting_key = $1 
  AND end_time IS NULL 
LIMIT 1
`

func (q *Queries) GetActiveMeetingByKey(ctx context.Context, meetingKey string) (Meeting, error) {
	row := q.db.QueryRow(ctx, getActiveMeetingByKey, meetingKey)
	var i Meeting
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.HostID,
		&i.RoomName,
		&i.MeetingKey,
		&i.StartTime,
		&i.EndTime,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getMeetingByID = `-- name: GetMeetingByID :one
SELECT id, title, description, host_id, room_name, meeting_key, start_time, end_time, is_active, created_at FROM meetings
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMeetingByID(ctx context.Context, id pgtype.UUID) (Meeting, error) {
	row := q.db.QueryRow(ctx, getMeetingByID, id)
	var i Meeting
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.HostID,
		&i.RoomName,
		&i.MeetingKey,
		&i.StartTime,
		&i.EndTime,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getMeetingByRoomName = `-- name: GetMeetingByRoomName :one
SELECT id, title, description, host_id, room_name, meeting_key, start_time, end_time, is_active, created_at FROM meetings
WHERE room_name = $1 AND end_time IS NULL 
LIMIT 1
`

func (q *Queries) GetMeetingByRoomName(ctx context.Context, roomName string) (Meeting, error) {
	row := q.db.QueryRow(ctx, getMeetingByRoomName, roomName)
	var i Meeting
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.HostID,
		&i.RoomName,
		&i.MeetingKey,
		&i.StartTime,
		&i.EndTime,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getMeetingInvites = `-- name: GetMeetingInvites :many
SELECT user_id FROM meeting_invites
WHERE meeting_id = $1
`

func (q *Queries) GetMeetingInvites(ctx context.Context, meetingID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getMeetingInvites, meetingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMeetingsForUser = `-- name: ListMeetingsForUser :many
SELECT m.id, m.title, m.description, m.host_id, m.room_name, m.meeting_key, m.start_time, m.end_time, m.is_active, m.created_at FROM meetings m
INNER JOIN meeting_invites mi ON m.id = mi.meeting_id
WHERE mi.user_id = $1 
  AND m.end_time IS NULL
ORDER BY m.start_time ASC
`

func (q *Queries) ListMeetingsForUser(ctx context.Context, userID string) ([]Meeting, error) {
	rows, err := q.db.Query(ctx, listMeetingsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meeting
	for rows.Next() {
		var i Meeting
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.HostID,
			&i.RoomName,
			&i.MeetingKey,
			&i.StartTime,
			&i.EndTime,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMyMeetings = `-- name: ListMyMeetings :many
SELECT DISTINCT m.id, m.title, m.description, m.host_id, m.room_name, m.meeting_key, m.start_time, m.end_time, m.is_active, m.created_at
FROM meetings m
LEFT JOIN meeting_invites mi ON m.id = mi.meeting_id
WHERE (m.host_id = $1 OR mi.user_id = $1)
  AND m.end_time IS NULL
ORDER BY m.start_time ASC
`

func (q *Queries) ListMyMeetings(ctx context.Context, userID string) ([]Meeting, error) {
	rows, err := q.db.Query(ctx, listMyMeetings, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meeting
	for rows.Next() {
		var i Meeting
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.HostID,
			&i.RoomName,
			&i.MeetingKey,
			&i.StartTime,
			&i.EndTime,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMeetingStatus = `-- name: UpdateMeetingStatus :exec
UPDATE meetings
SET is_active = $2
WHERE id = $1
`

type UpdateMeetingStatusParams struct {
	ID       pgtype.UUID `json:"id"`
	IsActive pgtype.Bool `json:"is_active"`
}

func (q *Queries) UpdateMeetingStatus(ctx context.Context, arg UpdateMeetingStatusParams) error {
	_, err := q.db.Exec(ctx, updateMeetingStatus, arg.ID, arg.IsActive)
	return err
}
